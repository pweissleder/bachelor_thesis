import asyncio
import json
import logging
import re
import traceback
from queue import Empty
from datetime import datetime
import copy

from src.communicators.mqtt_communicator import LEADER_QOS, COMMAND_QOS, pop_message, COMMAND_RESPONSE_QOS, \
    GATEWAY_QOS
from src.device_integrations.prototype.myStrom.my_strom_device_integration import MyStromDeviceIntegration
from src.device_integrations.prototype.shelly.shelly_device_integration import ShellyDeviceIntegration
from src.device_integrations.mock.mocks import MockDeviceIntegration
from src.models.devices.device import Command, Device
from src.models.devices.nodeID import NodeID

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)


async def execute_with_timeout(task, timeout, message=""):
    try:
        await asyncio.wait_for(task, timeout=timeout)
    except asyncio.TimeoutError:
        if message:
            print('The tasks took too long to complete and were cancelled.Details:', message)
        raise


class Gateway:
    patterns = {
        "gateway": "gateways/{id}",
        "gateway_reachable": "gateways/{id}/reachable",
        "device_command": "devices/{id}/command",
        "device_command_response": "devices/{id}/command/r",
        "device_leader": "devices/{id}/leader",
        "device": "devices/{id}"
    }

    DEVICE_UPDATE_TIME = 0.01
    DEVICE_BACKUP_MULTIPLIER = 10000  # periodic updates of all devices in case an interested is not updated
    DEVICE_FINDER_UPDATE_TIME = 1

    SERVER_CONNECT_TIMEOUT = 10.0
    MQTT_CONNECT_TIMEOUT = 10.0

    SERVER_RECONNECT_TIMEOUT = 10.0
    MQTT_RECONNECT_TIMEOUT = 10.0

    GATEWAY_TOPIC = None

    rest_communicator = None  # Communicator to server
    message_communicator = None  # Communicator to devices

    device_integrations = None

    # Authentication
    auth_token = None  # Hard coded token to verify legitimate registration requests
    session_token = None  # Token to verify the gateway for operation
    expire_date = None  # Date when the session token expires

    gateway_id = None  # Unique ID for the gateway, generated by the server

    devices_access_condition = asyncio.Condition()

    active_devices = {}
    reachable_devices = {}

    def __init__(self, gateway_id, auth_token, rest_communicator, message_communicator):
        self.rest_communicator = rest_communicator
        self.message_communicator = message_communicator

        self.gateway_id = gateway_id
        self.auth_token = auth_token

        self.GATEWAY_TOPIC = self.create_topic("gateway", gateway_id)

    def set_session_token(self, token):
        self.session_token = token

    def set_gateway_id(self, gateway_id):
        self.gateway_id = gateway_id

    def set_expire_date(self, expire_date):
        self.expire_date = expire_date

    def is_session_token_valid(self):
        if self.expire_date is None:
            return False
        return datetime.now() < self.expire_date

    # Generate a topic string by inserting an ID into the pattern.
    def create_topic(self, pattern_key, gateway_id):
        if pattern_key not in self.patterns:
            raise ValueError("Invalid pattern key provided.")
        # Format the string with the provided ID
        return self.patterns[pattern_key].format(id=gateway_id)

    # Check if the given topic matches any known pattern, return the pattern key and extracted id.
    def match_topic(self, topic):
        for key, pattern in self.patterns.items():
            regex_pattern = "^" + re.escape(pattern).replace(r'\{id\}', r'([^/]+)') + "$"
            match = re.match(regex_pattern, topic)
            if match:
                return key, match.group(1)
        return None, None

    async def authenticate_gateway(self):
        async with self.rest_communicator as communicator:
            while not communicator.is_connected():
                communicator.connect()
                await asyncio.sleep(5)

            if self.is_session_token_valid():
                return

            response = await communicator.get_session_token(self.gateway_id, self.auth_token)
            if all(response):
                gateway_id, session_token, expire_date = response
                self.set_session_token(session_token)
                self.set_expire_date(expire_date)
            else:
                raise Exception("Failed to get session token.")

    async def setup_gateway(self):
        connected_to_server, connected_to_mqtt = False, False
        while not connected_to_server and not connected_to_mqtt:
            try:
                async with self.rest_communicator:
                    await execute_with_timeout(self.authenticate_gateway(),
                                               self.SERVER_CONNECT_TIMEOUT,
                                               f'Authentication failed!Try again in {self.SERVER_RECONNECT_TIMEOUT} seconds ...')
                    connected_to_server = True
            except OSError as e:
                logger.debug(e)
                await asyncio.sleep(self.MQTT_RECONNECT_TIMEOUT)
            except Exception as e:
                logger.debug(e)
                await asyncio.sleep(self.SERVER_RECONNECT_TIMEOUT)
            try:
                async with self.rest_communicator:
                    await execute_with_timeout(self.message_communicator.connect(),
                                               self.MQTT_CONNECT_TIMEOUT,
                                               f'MQTT Connection failed! Try again in {self.MQTT_RECONNECT_TIMEOUT} seconds ...')
                    connected_to_mqtt = True
            except OSError as e:
                logger.debug(e)
                await asyncio.sleep(self.MQTT_RECONNECT_TIMEOUT)
            except Exception as e:
                logger.debug(e)
                await asyncio.sleep(self.MQTT_RECONNECT_TIMEOUT)

    async def run(self):
        try:
            listen_for_commands = asyncio.create_task(self.handle_received_massages())
            listen_for_state_changes = asyncio.create_task(self.device_state_listener())
            listen_for_devices = asyncio.create_task(self.device_listener())

            tasks = [listen_for_commands,
                     listen_for_state_changes,
                     listen_for_devices]

            await asyncio.gather(
                *tasks
            )
        except Exception as e:
            logger.exception(e)
            traceback.print_stack()
            self.message_communicator.stop_loop()
            await asyncio.sleep(1)

    async def setup_integrations(self):

        self.device_integrations = {
            "MockDeviceFinder": MockDeviceIntegration(),
            "MyStromDeviceFinder": MyStromDeviceIntegration(),
            "ShellyDeviceFinder": ShellyDeviceIntegration(),
        }

    def start_message_loop(self):
        print("Starting Message Loop")
        self.message_communicator.start_loop(self.gateway_id)

    async def device_listener(self):
        print("Starting Device Listener")
        while True:
            for device_finder in self.device_integrations.values():
                try:
                    devices_rm = False
                    discovered_devices, removed_devices = await device_finder.get_devices()

                    logger.info("... %s search finished! len: %s",
                                device_finder.__class__.__name__, len(discovered_devices))
                    async with self.devices_access_condition:
                        # only devices which are newly new are added to the new device list
                        reachable_ids = {device.id for device in self.reachable_devices.values()}
                        filtered_new_devices = [device for device in discovered_devices if
                                                device.id not in reachable_ids]

                        for device in filtered_new_devices:
                            # Subscribe to new Devices
                            device_command_topic = self.create_topic("device_command", device.id.to_string())
                            device_leader_topic = self.create_topic("device_leader", device.id.to_string())

                            self.message_communicator.client.subscribe([
                                (device_leader_topic, LEADER_QOS),
                                (device_command_topic, COMMAND_QOS)
                            ])

                            # add all new discovered devices into list: Only needed if all integration update in
                            # device itself. Need for Callbacks
                        for device in discovered_devices:
                            self.reachable_devices[device.id] = device

                            if self.active_devices.get(device.id) is not None:
                                self.active_devices[device.id] = device

                        for device in removed_devices:
                            self.reachable_devices.pop(device.id)
                            if self.reachable_devices.get(device.id) is None:
                                self.active_devices.pop(device.id)
                            devices_rm = True

                        if len(filtered_new_devices) > 0 or devices_rm:
                            payload = self.build_gateway_payload()

                            self.message_communicator.client.publish(topic=self.GATEWAY_TOPIC,
                                                                     payload=payload,
                                                                     qos=GATEWAY_QOS,
                                                                     retain=True)
                        self.devices_access_condition.notify()
                    await asyncio.sleep(2)
                except Exception as e:
                    logger.exception(e)
                    traceback.print_stack()
                    await asyncio.sleep(5)

    async def device_state_listener(self):
        print("Starting Device State Listener")
        periodic_backup_push_ctr = 0
        old_device_states = {}
        while True:
            # print("Active Devices: ")
            for new_device in self.active_devices.values():
                async with (self.devices_access_condition):
                    try:
                        assert new_device is not None and isinstance(new_device, Device)
                        # print(str(new_device.to_dict()))
                        old_device_hash: int = old_device_states.get(new_device.id)

                        if (old_device_hash is not None and not new_device.has_changed(old_device_hash)) and periodic_backup_push_ctr != self.DEVICE_BACKUP_MULTIPLIER:
                            continue
                        payload = self.build_device_payload(new_device)

                        self.message_communicator.client.publish(
                            topic=self.create_topic("device", new_device.id.to_string()),
                            payload=payload,
                            qos=GATEWAY_QOS,
                            retain=True
                        )
                    except Exception as e:
                        logger.exception(e)
                        self.devices_access_condition.notify()
                    self.devices_access_condition.notify()
                async with (self.devices_access_condition):
                    old_device_states = self.build_old_device_states()
                    self.devices_access_condition.notify()
            if periodic_backup_push_ctr == self.DEVICE_BACKUP_MULTIPLIER:
                periodic_backup_push_ctr = -1
            periodic_backup_push_ctr += 1
            await asyncio.sleep(self.DEVICE_UPDATE_TIME)

    async def handle_received_massages(self):
        print("Starting Message Handler")
        while True:
            try:
                try:
                    message = pop_message()
                except Empty:
                    await asyncio.sleep(1)
                    continue

                handler = {
                    "device_command": self.handle_command_message,
                    "device_leader": self.handle_leader_message,
                }

                pattern_key, topic_id = self.match_topic(message.topic)

                if pattern_key and handler.get(pattern_key) is not None:
                    await handler[pattern_key](message)

            except Exception as e:
                logger.exception(e)
                traceback.print_stack()

    async def handle_command_message(self, message):
        try:
            decoded_message = str(message.payload.decode("utf-8"))
            logger.info(f"Handling command message: \n {decoded_message}")

            command_message: Command = Command.from_json(message.payload.decode("utf-8"))
            node_id = NodeID.from_composite_id(command_message.nodeId.to_string())

            device: Device = self.active_devices.get(node_id)

            if device is None:
                raise Exception("No active device found with corresponding id")

            async with self.devices_access_condition:
                logging.debug(f"Prior command: {device.to_dict()}")
                await device.apply_commands(command_message.endpoint, command_message.cluster,
                                            command_message.command, command_message.attribute)

                # self.active_devices[node_id] = device
                logging.debug(f"After command:{device.to_dict()}")

                topic = self.create_topic("device_command_response", device.id.to_string())  # potential error with ID
                self.message_communicator.client.publish(topic, COMMAND_RESPONSE_QOS)

                logger.info(f"Applied command: {command_message.command} to device: {device.id}")

                self.devices_access_condition.notify()
        except Exception as e:
            logger.exception(e)
            traceback.print_stack()
            await asyncio.sleep(1)

    async def handle_leader_message(self, message):
        try:
            decoded_message = str(message.payload.decode("utf-8"))
            logger.info(f"Handling leader message: \n {decoded_message}")

            if decoded_message == self.gateway_id:
                device_id = message.topic.split("/")[1]
                node_id = NodeID.from_composite_id(device_id)

                device: Device = self.reachable_devices.get(node_id)
                if device is None:
                    logger.debug("No reachable device found with corresponding id")

                self.active_devices[node_id] = device

                payload = self.build_gateway_payload()

                self.message_communicator.client.publish(topic=self.GATEWAY_TOPIC,
                                                         payload=payload,
                                                         qos=GATEWAY_QOS,
                                                         retain=True)
            return
        except Exception as e:
            logger.exception(e)
            traceback.print_stack()

    def build_device_payload(self, device: Device):
        assert device is not None
        device_info = {
            'id': device.id.to_dict(),
            'endpoints': [endpoint.to_dict() for endpoint in device.endpoints],
        }
        matter_node_json = json.dumps(device_info)
        return matter_node_json

    def build_gateway_payload(self) -> str:
        gateway_info = {
            'gatewayId': self.gateway_id,
            'activeDevices': [node.to_dict() for node in self.active_devices.keys()],
            'reachableDevices': [node.to_dict() for node in self.reachable_devices.keys()]
        }
        gateway_info_json = json.dumps(gateway_info)
        return gateway_info_json

    def build_old_device_states(self) -> dict[NodeID, int]:
        old_device_states = {}
        for device in self.active_devices.values():
            old_device_states[device.id] = hash(device)
        return old_device_states
